%% Code to correct errors in the toe_onhore variable in the morphologies

NAME_GRD_transects  = {'San_Diego','Orange','Los_Angeles','Ventura','Santa_Barbara',...
    'Santa_Barbara_West','San_Luis_Obispo','Monterey','Santa_Cruz','San_Mateo','San_Francisco',...
    'Marin','Sonoma','Mendocino','Humboldt','Del_Norte','Curry','Coos','Douglas','Lane',...
    'Lincoln','Tillamook','Clatsop','Pacific','Grays_Harbor','Jefferson','Clallam'}; 


for WestCoast=1:17
    DirIn=['F:\West_Coast_TWL_Hazards\03_Results\' NAME_GRD_transects{WestCoast} '\Morphology_Updated'];
    load(['F:\West_Coast_TWL_Hazards\03_Results\', NAME_GRD_transects{WestCoast}, '\time_series_reconstructed',filesep,'ii_grid_array.mat']);
    Ntr=ii_grid_array;
      DirOut=['F:\West_Coast_TWL_Hazards\03_Results' filesep NAME_GRD_transects{WestCoast} filesep, 'Morphology_Fix_Toe'];
    if ~exist(DirOut,'dir'), mkdir(DirOut); end
    
    % Loop through each transect 
    for ii=Ntr
     OBJECTID=dec2base(ii,10,4);
     try
        load([DirIn filesep 'SlopeInfo_Transect_' num2str(ii) '.mat']);
     catch
    	continue   
     end
    
     %If a cliff location or a seawall location
     if SlopeInfo.maxi==0 || SlopeInfo.toe_loc==-1 || ~isempty(SlopeInfo.Rey) || SlopeInfo.toe_loc>30;
         save([DirOut filesep 'SlopeInfo_Transect_' num2str(ii) '.mat'], 'SlopeInfo');
         continue
     end
     
    L=[1:length(SlopeInfo.depth)];
    depth=SlopeInfo.depth;
    result = DouglasPeucker([L;depth],0.2);
    fepth=interp1(result(1,:),result(2,:),L); 
    a=diff(fepth);%1st derivative
    b=diff(a);%2nd derivative
    
    ESI=SlopeInfo.ESI;
    toe=SlopeInfo.toe_loc;
    
    %find toe location approximation based on tested thresholds
    if strcmp(ESI,'3A') && toe>100 || strcmp(ESI,'4') && toe>100
        [pks,locs] = findpeaks(b,[],1,0.07);
        locs(locs<30)=[];
    elseif strcmp(ESI,'3A') && toe>50 || ~strcmp(class(ESI),'char') && toe>50
        [pks,locs] = findpeaks(b,[],1,0.1);
    else
        [pks,locs] = findpeaks(b,[],1,0.15);    
    end

a=find(a<0);
locs(ismember(locs,a))=[];
    
    
if ~isempty(locs)
for mm=1:length(locs);
    if locs(mm)<=toe
        continue
    else
    nn=depth(toe:locs(mm));
    nn=diff(nn);nn=diff(nn);
    nn=find(nn>0.1);
    if ~isempty(nn)
        tab(mm)=mm;
    end
    end
end   

    if exist('tab','var')
        tab(tab==0)=[];
    if ~isempty(tab);
        locs(tab>0)=[];
    end
    end
end
[~,fire] = findpeaks(b*-1,[],1,0.05);

if ~isempty(fire)
    locs(locs>fire(1))=[];
end  

%% Determine if the locations retrieved may be erronous and remove them from vector

locs(locs<SlopeInfo.MHW)=[];
locs(locs<2.5)=[];
locs(locs>SlopeInfo.maxi)=[];
locs(locs>SlopeInfo.CliffJun_Loc)=[];

% determine toe_onshore variable, whcih is not necessarily consistent with
% the toe generated by the morphology analysis M5a
if ~isempty(locs);
toe_onshore=locs(1);
else
   toe_onshore=SlopeInfo.toe_onshore; 
end
    
%% 
  
if toe_onshore>0
    %common sense chack, a toe should not be more than 7m in any
    %circumstance. If so, redo
if depth(toe_onshore) > 7
    result = DouglasPeucker([L;depth],1.0);
    depth8=interp1(result(1,:),result(2,:),L);
    tmp=depth8(1:toe_onshore);
    %find a new toe inflection
    Dvec = diff(tmp);
    rmp=diff(Dvec);
    [pks,locs] = findpeaks(rmp,[],1,0.25);
    if ~isempty(locs)
    locs=locs+1;
    locs(locs>toe_onshore)=[];
    tmp=depth(locs);
    tmp=find(tmp>7);
    locs(tmp)=[];
    if ~isempty(locs)
        toe_onshore=locs(1);
    else
        toe_onshore=1;
    end
    end
end
else
    toe_onshore=1;
end
    
    
    SlopeInfo.toe_onshore=toe_onshore;
    
    save([DirOut filesep 'SlopeInfo_Transect_' num2str(ii) '.mat'], 'SlopeInfo');
    
    
    clear tab
    
    end
end